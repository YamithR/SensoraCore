DESCRIPCI√ìN DE OBRA - C√ìDIGO PRINCIPAL SENSORACORE
=======================================================

DESCRIPCI√ìN:
El c√≥digo principal de SensoraCore es una aplicaci√≥n desktop integral desarrollada en Python que act√∫a como interfaz de control unificada para un sistema de instrumentaci√≥n cient√≠fica distribuida basado en microcontrolador ESP32. Esta aplicaci√≥n constituye el n√∫cleo del sistema de monitoreo de sensores, proporcionando una plataforma robusta y escalable para la adquisici√≥n, procesamiento, visualizaci√≥n y an√°lisis de datos provenientes de 11 m√≥dulos especializados de sensores diferentes.

La aplicaci√≥n implementa una arquitectura modular avanzada que permite el manejo simult√°neo de m√∫ltiples tipos de sensores (anal√≥gicos, digitales, comunicaci√≥n serie), cada uno con sus propios protocolos de comunicaci√≥n, algoritmos de procesamiento y interfaces de usuario especializadas. El sistema est√° dise√±ado para aplicaciones educativas, cient√≠ficas e industriales que requieren monitoreo en tiempo real con capacidades de calibraci√≥n, an√°lisis estad√≠stico y exportaci√≥n de datos profesional.

DISE√ëO:
La arquitectura del sistema principal se fundamenta en un patr√≥n de dise√±o orientado a objetos con separaci√≥n de responsabilidades en m√∫ltiples capas arquitect√≥nicas:

1. Capa de Presentaci√≥n (UI Layer):
   - Clase `ui` como controlador principal heredando de QMainWindow
   - Sistema de carga din√°mica de interfaces (.ui) utilizando QUiLoader para m√°xima flexibilidad
   - Funci√≥n `app_path()` que resuelve rutas de recursos tanto en desarrollo como en ejecutables PyInstaller (onefile/onedir)
   - Widget de splash screen (`LoadingSplashScreen`) con barra de progreso para inicializaci√≥n profesional
   - Gesti√≥n din√°mica de widgets de sensores con creaci√≥n y destrucci√≥n controlada de instancias

2. Capa de L√≥gica de Aplicaci√≥n:
   - Sistema de gesti√≥n de conexiones TCP/IP con el ESP32 mediante clase `ESP32Client`
   - Administrador de estados de sensores con limpieza autom√°tica de recursos (`_cleanup_active_sensors`)
   - Controlador de selecci√≥n de sensores (`sensorSeleccionado`) con gesti√≥n robusta de fallos
   - Sistema de logging en tiempo real con ventana dedicada y redirecci√≥n de streams (`EmittingStream`)

3. Capa de Comunicaci√≥n:
   - Protocolo TCP personalizado para comunicaci√≥n bidireccional con ESP32
   - Sistema de comandos especializados por m√≥dulo de sensor
   - Gesti√≥n de timeouts y reconexi√≥n autom√°tica para robustez en entornos industriales
   - Validaci√≥n de comandos y respuestas con manejo de errores comprehensive

4. Capa de Gesti√≥n de M√≥dulos:
   - Importaci√≥n din√°mica de 11 m√≥dulos especializados de sensores
   - Instanciaci√≥n controlada de l√≥gicas espec√≠ficas por sensor
   - Sistema de referencias circulares para comunicaci√≥n entre ventana principal y m√≥dulos
   - Gesti√≥n de ciclo de vida completo con cleanup autom√°tico al cambiar de sensor

La arquitectura de la interfaz gr√°fica implementa un dise√±o adaptativo con contenedor principal (`SensorUI`) que aloja din√°micamente las interfaces espec√≠ficas de cada sensor, widget de bienvenida personalizable y sistema de botones de sensor con habilitaci√≥n condicional basada en estado de conexi√≥n.

IMPLEMENTACI√ìN:
La implementaci√≥n utiliza tecnolog√≠as modernas de Python con enfoque en robustez, mantenibilidad y rendimiento:

Tecnolog√≠as Base:
- Python 3.8+ con type hints para desarrollo robusto y autodocumentaci√≥n
- PySide6 (Qt 6.x) para interfaz gr√°fica nativa multiplataforma
- Arquitectura de hilos (`QThread`) para operaciones no bloqueantes
- Sistema de se√±ales Qt para comunicaci√≥n as√≠ncrona entre componentes

Componentes Principales Implementados:

1. Sistema de Resoluci√≥n de Rutas (`app_path`):
   - Compatibilidad completa con PyInstaller en modo onefile y onedir
   - B√∫squeda inteligente en m√∫ltiples ubicaciones base (sys._MEIPASS, directorio ejecutable, CWD, ra√≠z del repositorio)
   - Fallback robusto para garantizar funcionamiento en cualquier entorno de despliegue
   - Soporte para recursos embebidos y estructura de desarrollo

2. Splash Screen Profesional (`LoadingSplashScreen`):
   - Ventana sin marco con dise√±o moderno y barra de progreso animada
   - Timer autom√°tico con simulaci√≥n de carga para experiencia de usuario fluida
   - Estilos CSS integrados para apariencia profesional
   - Gesti√≥n autom√°tica de ciclo de vida y transici√≥n a ventana principal

3. Controlador Principal (`ui`):
   - Inicializaci√≥n completa de 12 widgets de sensores usando QUiLoader
   - Sistema de mapeo din√°mico de botones a IDs de sensores para m√°xima flexibilidad
   - Gesti√≥n robusta de estados de conexi√≥n con actualizaci√≥n visual en tiempo real
   - Implementaci√≥n de patrones observer para actualizaciones de interfaz

4. Sistema de Conexi√≥n ESP32:
   - Funci√≥n `conectar()` con validaci√≥n de IP, prueba de conectividad y actualizaci√≥n de UI
   - Protocolo de handshake con comando `LED_ON` para verificaci√≥n de comunicaci√≥n
   - Manejo de timeouts y errores de red con feedback visual inmediato
   - Habilitaci√≥n autom√°tica de controles de sensor tras conexi√≥n exitosa

5. Gestor de Selecci√≥n de Sensores (`sensorSeleccionado`):
   - Limpieza autom√°tica de procesos activos antes de cambio de sensor
   - Recreaci√≥n din√°mica de widgets con validaci√≥n de integridad
   - Sistema de fallback para recuperaci√≥n autom√°tica de errores de widget
   - Instanciaci√≥n controlada de l√≥gicas espec√≠ficas con manejo de excepciones

6. Sistema de Limpieza de Recursos (`_cleanup_active_sensors`):
   - Detenci√≥n controlada de todos los procesos activos de sensores
   - Llamada a m√©todos `cleanup()` espec√≠ficos de cada m√≥dulo
   - Liberaci√≥n de memoria y recursos de red de forma segura
   - Prevenci√≥n de memory leaks en operaci√≥n continua

7. Funci√≥n de Reset Completo (`reset`):
   - Restauraci√≥n completa del estado inicial de la aplicaci√≥n
   - Recreaci√≥n de todos los widgets de sensores desde cero
   - Deshabilitaci√≥n de controles y actualizaci√≥n de estados visuales
   - Limpieza de ventana de log con restauraci√≥n de streams est√°ndar

8. Sistema de Logging Avanzado:
   - Ventana de log dedicada con estilo terminal profesional
   - Redirecci√≥n de stdout y stderr para captura completa de debug
   - Toggle de visibilidad con gesti√≥n autom√°tica de recursos
   - Fuente monoespaciada y colores para legibilidad m√°xima

Patrones de Dise√±o Implementados:
- Singleton impl√≠cito para ventana principal
- Factory pattern para creaci√≥n de widgets de sensores
- Observer pattern para actualizaciones de UI
- Command pattern para protocolo de comunicaci√≥n ESP32
- State pattern para gesti√≥n de modos de sensor

Gesti√≥n de Errores y Robustez:
- Try-catch granular en todas las operaciones cr√≠ticas
- Validaci√≥n de existencia de widgets antes de operaciones
- Sistema de fallback para recreaci√≥n autom√°tica de componentes
- Logging detallado para debugging y mantenimiento
- Timeouts configurables para operaciones de red

FUNCIONES:
El sistema principal proporciona un conjunto completo de funcionalidades para operaci√≥n cient√≠fica e industrial:

Funci√≥n `app_path(*parts)` - Resoluci√≥n Inteligente de Rutas:
- **Prop√≥sito**: Resolver rutas absolutas v√°lidas para archivos de datos incluidos con PyInstaller o en ejecuci√≥n normal
- **B√∫squeda sistem√°tica**: 
  - sys._MEIPASS para PyInstaller onefile
  - Directorio del ejecutable y subcarpeta "_internal" para PyInstaller onedir
  - Directorio de trabajo actual (CWD) y CWD/_internal
  - Ra√≠z del repositorio (dos niveles arriba del archivo main.py)
- **Algoritmo**: Itera por bases de b√∫squeda hasta encontrar archivo existente o retorna fallback
- **Casos de uso**: Carga de archivos .ui, recursos media, configuraciones JSON

Clase `LoadingSplashScreen(QWidget)` - Pantalla de Inicio Profesional:
- **Arquitectura**: Widget sin marco con QVBoxLayout para componentes verticales
- **Componentes visuales**:
  - T√≠tulo "SensoraCore" con fuente 18px, peso 600, color #333
  - Label de estado "Iniciando‚Ä¶" centrado, color #555
  - Barra de progreso QProgressBar con estilo personalizado CSS
- **Mec√°nica de progreso**: QTimer con intervalos de 30ms, incremento +1% hasta 100%
- **Estilizaci√≥n**: Fondo blanco, borde gris #c0c0c0, radio de borde 8px, tama√±o fijo 420x110

Funciones de Inicializaci√≥n y Configuraci√≥n:
- `__init__()`: Constructor principal con carga de todas las interfaces y configuraci√≥n de eventos
- Configuraci√≥n autom√°tica de 12 widgets de sensores con validaci√≥n de integridad
- Mapeo din√°mico de botones a funciones de callback para m√°xima flexibilidad

Constructor `ui.__init__()` - Inicializaci√≥n del Sistema Principal:
- **Carga de UI principal**: QUiLoader para cargar mainWindow.ui desde app_path()
- **Configuraci√≥n de 12 widgets de m√≥dulos**: Carga individual de archivos .ui por sensor:
  - simpleAngleUi, angleArmUi, infraredUi, capasitiveUi, ultrasonicUi
  - opticalSpeedUi, irSteeringUi, thermoregulationUi, gasRegulationUi
  - brightnessUi, colorCNYUi, colorTCSUi
- **Configuraci√≥n de eventos**:
  - Bot√≥n "Conectar" ‚Üí self.conectar()
  - Bot√≥n "Terminal" ‚Üí self.toggle_ventana_log()
  - Bot√≥n "resetBT" ‚Üí self.reset()
- **Mapeo din√°mico de sensores**: Diccionario sensor_buttons_map con lambda functions
- **Inicializaci√≥n de variables**: log_window=None, welcome_widget reference

Funciones de Gesti√≥n de Conexi√≥n:
- `conectar()`: Establece conexi√≥n TCP con ESP32 con validaci√≥n completa y feedback visual
- Validaci√≥n de formato IP con mensajes de error espec√≠ficos
- Prueba de conectividad mediante comando LED_ON con timeout configurable
- Actualizaci√≥n autom√°tica de estados visuales y habilitaci√≥n de controles

Funci√≥n `conectar()` - Establecimiento de Conexi√≥n con ESP32:
- **Validaci√≥n de widgets**: Verificaci√≥n de existencia de ipEdit, Conectar, Status y botones de sensores
- **Validaci√≥n de IP**: Verificaci√≥n de campo no vac√≠o con mensaje de advertencia
- **Feedback visual durante conexi√≥n**:
  - Deshabilitaci√≥n del bot√≥n "Conectar"
  - Actualizaci√≥n de status a "üîÑ Conectando..." con estilo CSS azul
  - Repaint() forzado para actualizaci√≥n inmediata
- **Protocolo de handshake**:
  - Creaci√≥n de cliente ESP32Client(esp32_ip)
  - Env√≠o de comando LED_ON para verificaci√≥n
  - Validaci√≥n de respuesta "LED_ON_OK"
- **Manejo de estados post-conexi√≥n**:
  - √âxito: Status "‚úÖ Conectado", estilo verde, habilitaci√≥n de sensores
  - Fallo: Status "‚ùå Error", estilo rojo, mantener botones deshabilitados
- **Notificaciones**: QMessageBox para informaci√≥n/error al usuario

Funci√≥n `reset()` - Reinicio Completo del Sistema:
- **Limpieza de procesos activos**: Llamada a _cleanup_active_sensors()
- **Gesti√≥n de ventana de log**:
  - Cierre de log_window si est√° visible
  - Restauraci√≥n de sys.stdout y sys.stderr a valores originales
- **Deshabilitaci√≥n de botones de sensores**: Array de 12 botones sensor_buttons[]
- **Limpieza del √°rea de sensores**:
  - Eliminaci√≥n de layout actual con takeAt(0) loop
  - deleteLater() para widgets hijos
  - Creaci√≥n de nuevo QVBoxLayout limpio
- **Recreaci√≥n de widgets**: Llamada a _recreate_sensor_widgets()
- **Recreaci√≥n de welcome_widget**: Nuevo widget con ObjectName "Welcome"

Funci√≥n `_recreate_sensor_widgets()` - Recreaci√≥n de Widgets de Sensores:
- **Limpieza previa**: Llamada a _cleanup_active_sensors()
- **Recreaci√≥n sistem√°tica**: QUiLoader para cargar 12 archivos .ui:
  - simpleAngleUi, angleArmUi, infraredUi, capasitiveUi
  - ultrasonicUi, opticalSpeedUi, irSteeringUi, thermoregulationUi
  - gasRegulationUi, brightnessUi, colorCNYUi, colorTCSUi
- **Manejo de errores**: Try-catch con logging espec√≠fico de fallos

Funci√≥n `sensorSeleccionado(sensor_id)` - Selecci√≥n y Cambio de Sensor:
- **Par√°metro**: sensor_id (string) identificador del sensor a activar
- **Limpieza previa**: _cleanup_active_sensors() para detener procesos anteriores
- **Gesti√≥n de welcome_widget**:
  - Verificaci√≥n de existencia con hasattr()
  - setVisible(False) para ocultaci√≥n
  - Try-catch para RuntimeError si widget fue eliminado

Funciones de Selecci√≥n y Gesti√≥n de Sensores:
- `sensorSeleccionado()`: Cambia din√°micamente entre sensores con limpieza autom√°tica de estado anterior
- `_cleanup_active_sensors()`: Detiene todos los procesos activos con llamadas espec√≠ficas a cleanup de cada m√≥dulo
- `_recreate_sensor_widgets()`: Recrea widgets desde cero para recuperaci√≥n de errores
- `reconstruirSensorUi()`: Regenera widget espec√≠fico tras fallo de integridad

Funci√≥n `_cleanup_active_sensors()` - Limpieza Completa de Procesos Activos:
- **Prop√≥sito**: Detener todos los procesos activos de sensores antes de cambio o reset
- **Metodolog√≠a sistem√°tica**: Verificaci√≥n hasattr() para cada instancia de l√≥gica
- **Limpieza por sensor** (12 sensores):
  - current_simple_angle_logic ‚Üí cleanup()
  - current_angle_arm_logic ‚Üí cleanup()
  - current_infrared_logic ‚Üí cleanup()
  - current_capasitive_logic ‚Üí cleanup()
  - current_ultrasonic_logic ‚Üí cleanup()
  - current_optical_speed_logic ‚Üí cleanup()
  - current_ir_steering_logic ‚Üí cleanup()
  - current_thermoregulation_logic ‚Üí cleanup()
  - current_gas_regulation_logic ‚Üí cleanup()
  - current_colorcny_logic ‚Üí cleanup()
  - current_brightness_logic ‚Üí cleanup()
  - current_colortcs_logic ‚Üí cleanup()
- **Manejo de errores**: Try-catch individual para cada sensor con logging espec√≠fico
- **Asignaci√≥n None**: Limpieza de referencias tras cleanup() exitoso
- **Logging detallado**: Print de estado para cada sensor procesado

Funciones de Reset y Limpieza:
- `reset()`: Restauraci√≥n completa del sistema al estado inicial pre-conexi√≥n
- Detenci√≥n controlada de todos los procesos ESP32 activos
- Recreaci√≥n de interfaz completa con widgets limpios
- Restauraci√≥n de estados de conexi√≥n y habilitaci√≥n de controles

Funci√≥n `closeEvent(event)` - Manejo Controlado del Cierre de Aplicaci√≥n:
- **Limpieza de procesos**: Llamada a _cleanup_active_sensors()
- **Gesti√≥n de ventana de log**:
  - Verificaci√≥n de existencia con hasattr()
  - Cierre de log_window si est√° visible
  - Restauraci√≥n de sys.stdout y sys.stderr a valores originales
- **Aceptaci√≥n del evento**: event.accept() para cierre limpio

Funci√≥n `toggle_ventana_log()` - Alternancia de Ventana de Log:
- **Verificaci√≥n de estado**: Comprobaci√≥n si log_window existe y es visible
- **Cierre**: log_window.close() y asignaci√≥n None
- **Apertura**: Llamada a abrir_ventana_log()

Funci√≥n `abrir_ventana_log()` - Creaci√≥n de Ventana de Log:
- **Ventana principal**: QMainWindow(self) con t√≠tulo "Log de Depuraci√≥n"
- **Geometr√≠a**: setGeometry(100, 100, 600, 400)
- **Widget de texto**: QTextEdit con setReadOnly(True)
- **Estilizaci√≥n**: Fondo negro, texto blanco, fuente Consolas 12px
- **Redirecci√≥n de streams**: sys.stdout y sys.stderr a EmittingStream

Funci√≥n `reconstruirSensorUi(sensor_id)` - Reconstrucci√≥n de Widget Espec√≠fico:
- **Par√°metro**: sensor_id para identificar sensor espec√≠fico a reconstruir
- **Creaci√≥n de QUiLoader**: Nueva instancia para carga limpia
- **Condicionales por sensor**: Switch-case para 12 tipos diferentes
- **Recarga de .ui**: loader.load() con app_path() para cada sensor
- **Retry autom√°tico**: Llamada recursiva a sensorSeleccionado() tras reconstrucci√≥n

Clase `ESP32Client` - Cliente TCP para Comunicaci√≥n con ESP32:
- **Constructor**: __init__(esp32_ip, port=8080)
- **M√©todo send_command(command)**:
  - Creaci√≥n de socket TCP con AF_INET, SOCK_STREAM
  - Configuraci√≥n de timeout a 3 segundos
  - Conexi√≥n a (esp32_ip, port)
  - Env√≠o de comando codificado con encode()
  - Recepci√≥n de respuesta con recv(1024)
  - Decodificaci√≥n con decode()
  - Manejo de excepciones con return "ERROR: {e}"
- **M√©todo led_on()**: Env√≠a comando 'LED_ON' para handshake
- **M√©todo led_off()**: Env√≠a comando 'LED_OFF' para pruebas

Clase `EmittingStream` - Redirecci√≥n de Streams a QTextEdit:
- **Constructor**: __init__(text_edit) recibe referencia a QTextEdit
- **M√©todo write(text)**: Redirige output a text_edit.append(text)
- **M√©todo flush()**: Implementaci√≥n vac√≠a para compatibilidad de interface
- **Prop√≥sito**: Capturar print() y errores para mostrar en ventana de log

Funci√≥n Principal `if __name__ == "__main__"`:
- **Inicializaci√≥n**: QApplication(sys.argv)
- **Splash screen**: Creaci√≥n y mostrado de LoadingSplashScreen
- **Simulaci√≥n de carga**: Loop de 100 iteraciones con sleep(0.02)
- **Carga de ventana principal**: Instanciaci√≥n de ui()
- **Cierre de splash**: splash.finish(window) o splash.close() con try-catch
- **Mostrado de ventana**: window.show()
- **Ejecuci√≥n**: app.exec()

Funciones de Logging y Debugging:
- `toggle_ventana_log()`: Alterna visibilidad de ventana de log con gesti√≥n autom√°tica de recursos
- `abrir_ventana_log()`: Crea ventana de log dedicada con redirecci√≥n de streams
- Sistema de captura completa de stdout/stderr para debugging avanzado
- Estilos profesionales de terminal con fuente monoespaciada

Funciones de Gesti√≥n de Eventos:
- `closeEvent()`: Manejo controlado del cierre de aplicaci√≥n con limpieza completa de recursos
- Detenci√≥n de todos los procesos activos antes del cierre
- Restauraci√≥n de streams est√°ndar y liberaci√≥n de memoria
- Prevenci√≥n de procesos zombie y leaks de recursos

Funciones de Gesti√≥n de Widgets:
- Carga din√°mica de 12 interfaces .ui utilizando QUiLoader para flexibilidad m√°xima
- Validaci√≥n de integridad de widgets con recreaci√≥n autom√°tica en caso de fallo
- Gesti√≥n de jerarqu√≠as parent-child para control de ciclo de vida
- Sistema de layout din√°mico con adici√≥n/remoci√≥n controlada de widgets

Funciones de Comunicaci√≥n y Protocolo:
- Integraci√≥n con clase ESP32Client para comunicaci√≥n TCP robusta
- Manejo de comandos espec√≠ficos por m√≥dulo con validaci√≥n de respuestas
- Sistema de timeout y reconexi√≥n para robustez en entornos industriales
- Protocolo de handshake con validaci√≥n de estado de microcontrolador

Funciones Auxiliares y Utilidades:
- Configuraci√≥n autom√°tica de estilos CSS para elementos de interfaz
- Gesti√≥n de timeouts de socket para operaciones no bloqueantes
- Validaci√≥n de formatos de entrada con mensajes de error espec√≠ficos
- Sistema de mapeo din√°mico para extensibilidad futura

VALIDACI√ìN:
El sistema principal implementa m√∫ltiples capas de validaci√≥n para garantizar operaci√≥n confiable en entornos cient√≠ficos e industriales:

Validaci√≥n de Inicializaci√≥n y Configuraci√≥n:
- Verificaci√≥n de carga exitosa de todas las interfaces .ui con fallback autom√°tico
- Validaci√≥n de existencia de widgets cr√≠ticos (botones, labels, contenedores)
- Comprobaci√≥n de integridad de mapeo de botones a funciones
- Test de resoluci√≥n de rutas para recursos embebidos y modo desarrollo

Validaci√≥n de Conectividad y Comunicaci√≥n:
- Verificaci√≥n de formato IP mediante regex y validaci√≥n de rango
- Test de conectividad TCP con timeout configurable y manejo de errores espec√≠ficos
- Validaci√≥n de protocolo de handshake con ESP32 mediante comando LED_ON
- Comprobaci√≥n de integridad de canal de comunicaci√≥n antes de operaciones cr√≠ticas

Validaci√≥n de Estados de Sensores:
- Verificaci√≥n de limpieza completa de procesos anteriores antes de cambio de sensor
- Validaci√≥n de existencia de instancias de l√≥gica antes de operaciones cleanup
- Comprobaci√≥n de integridad de widgets antes de operaciones de UI
- Test de creaci√≥n exitosa de nuevas instancias de m√≥dulos de sensor

Validaci√≥n de Gesti√≥n de Memoria:
- Verificaci√≥n de liberaci√≥n correcta de recursos de red y threading
- Validaci√≥n de destrucci√≥n apropiada de widgets Qt con deleteLater()
- Comprobaci√≥n de cleanup de referencias circulares entre objetos
- Test de ausencia de memory leaks en operaci√≥n continua

Validaci√≥n de Interfaz de Usuario:
- Verificaci√≥n de actualizaci√≥n correcta de estados visuales
- Validaci√≥n de habilitaci√≥n/deshabilitaci√≥n apropiada de controles
- Comprobaci√≥n de integridad de layout din√°mico tras adici√≥n/remoci√≥n de widgets
- Test de responsividad de interfaz durante operaciones de larga duraci√≥n

Validaci√≥n de Logging y Debugging:
- Verificaci√≥n de redirecci√≥n correcta de streams stdout/stderr
- Validaci√≥n de captura completa de mensajes de debug y error
- Comprobaci√≥n de toggleo apropiado de visibilidad de ventana de log
- Test de restauraci√≥n correcta de streams al cerrar aplicaci√≥n

Algoritmos de Auto-Validaci√≥n:
- Verificaci√≥n autom√°tica de integridad de widgets mediante try-catch con objectName()
- Detecci√≥n autom√°tica de widgets eliminados con recreaci√≥n transparente
- Validaci√≥n de estado de conexi√≥n antes de operaciones que requieren ESP32
- Sistema de heartbeat impl√≠cito para verificaci√≥n de salud del sistema

M√©tricas de Calidad Implementadas:
- Tiempo de respuesta de interfaz < 100ms para operaciones cr√≠ticas
- Tasa de √©xito de conexi√≥n > 95% en condiciones normales de red
- Ausencia completa de memory leaks en sesiones de 24+ horas
- Recuperaci√≥n autom√°tica de fallos de widget en < 2 segundos

Protocolos de Validaci√≥n Cient√≠fica:
- Trazabilidad completa de operaciones mediante logging detallado
- Validaci√≥n de integridad de datos antes de procesamiento por m√≥dulos
- Verificaci√≥n de sincronizaci√≥n correcta entre UI y estado interno
- Comprobaci√≥n de robustez ante condiciones adversas de red y hardware

PLATAFORMA:
El c√≥digo principal est√° dise√±ado para m√°xima compatibilidad y rendimiento en m√∫ltiples plataformas:

Plataforma de Desarrollo Base:
- Lenguaje: Python 3.8+ con type hints para robustez y mantenibilidad
- Framework GUI: PySide6 (Qt 6.x) para interfaz nativa multiplataforma
- Arquitectura: Orientada a objetos con patrones de dise√±o modernos
- Threading: QThread para operaciones as√≠ncronas sin bloqueo de UI
- Networking: Socket TCP nativo con gesti√≥n robusta de errores

Compatibilidad de Sistemas Operativos:
- Windows 10/11 (64-bit) - Plataforma principal validada para uso industrial
- Windows 7/8.1 - Compatibilidad heredada con limitaciones menores de rendimiento
- Linux Ubuntu 20.04 LTS+ y distribuciones cient√≠ficas (Debian, CentOS, Fedora)
- macOS 11+ (Big Sur) con soporte completo para procesadores Intel y Apple Silicon
- Raspberry Pi OS (ARM64) para implementaciones embebidas de laboratorio

Requisitos Hardware M√≠nimos:
- CPU: Dual-core 2.0 GHz (Intel Core i3, AMD A8, ARM Cortex-A72)
- RAM: 4 GB (8 GB recomendado para operaci√≥n simult√°nea de m√∫ltiples sensores)
- Almacenamiento: 2 GB disponibles (incluye runtime Python y dependencias Qt)
- Red: WiFi 802.11n o Ethernet 100Mbps para comunicaci√≥n estable con ESP32
- Puertos: USB 2.0+ para configuraci√≥n inicial y transferencia de datos

Configuraci√≥n Hardware Recomendada:
- CPU: Quad-core 3.0 GHz+ con soporte de virtualizaci√≥n para contenedores
- RAM: 16 GB+ para an√°lisis simult√°neo de datasets extensos
- SSD: 500 GB NVMe para almacenamiento r√°pido de datos experimentales
- GPU: Dedicada con soporte OpenGL 4.0+ para aceleraci√≥n de visualizaci√≥n
- Red: Gigabit Ethernet con switch dedicado para red de instrumentaci√≥n

Dependencias del Sistema:
- Python 3.8+: Instalaci√≥n oficial con bibliotecas est√°ndar completas
- PySide6: Framework Qt6 con soporte completo de widgets y multimedia
- Sistema Qt6: Bibliotecas nativas del sistema operativo
- Drivers de red: Stack TCP/IP nativo del sistema operativo
- Compilador C: Para extensiones nativas (GCC en Linux, MSVC en Windows, Xcode en macOS)

Gesti√≥n de Distribuci√≥n:
- PyInstaller: Empaquetado en ejecutables standalone (onefile/onedir)
- Resoluci√≥n autom√°tica de dependencias y recursos embebidos
- Compatibilidad con antivirus corporativos mediante certificados de c√≥digo
- Instaladores MSI para Windows con registro en sistema y shortcuts
- Packages .deb/.rpm para distribuciones Linux empresariales

AMBIENTE:
El ambiente de ejecuci√≥n est√° optimizado para aplicaciones cient√≠ficas, educativas e industriales:

Ambiente de Desarrollo:
- IDE Principal: VS Code con extensiones Python, Qt y Git para desarrollo colaborativo
- Control de versiones: Git con hooks pre-commit para calidad de c√≥digo
- Testing: pytest con fixtures especializadas para testing de GUI Qt
- Profiling: cProfile y line_profiler para optimizaci√≥n de rendimiento
- Documentation: Sphinx con temas cient√≠ficos para documentaci√≥n autom√°tica

Configuraci√≥n de Red para Producci√≥n:
- Protocolo: TCP/IP sobre Ethernet industrial o WiFi certificado IEEE 802.11
- Puerto: 8080 (configurable) con reglas de firewall espec√≠ficas
- Topolog√≠a: Red dedicada de instrumentaci√≥n separada de red corporativa
- Seguridad: Segmentaci√≥n VLAN para aislamiento de tr√°fico cient√≠fico
- Redundancia: Bonding de interfaces para alta disponibilidad en aplicaciones cr√≠ticas

Ambiente de Ejecuci√≥n Industrial:
- Directorio de trabajo: Configurable por administrador con permisos ACL apropiados
- Archivos de configuraci√≥n: ~/.sensoracore/ con backup autom√°tico programado
- Logging del sistema: Integraci√≥n con syslog y sistemas de monitoreo centralizados
- Persistencia de datos: Base de datos SQLite local con replicaci√≥n opcional
- Backup: Programaci√≥n autom√°tica de respaldo de configuraciones y calibraciones

Variables de Entorno Cr√≠ticas:
- PYTHONPATH: Configuraci√≥n autom√°tica para m√≥dulos SensoraCore y dependencias
- QT_QPA_PLATFORM: Optimizaci√≥n para rendering en sistemas headless y embebidos
- SENSORACORE_CONFIG_DIR: Override de directorio de configuraci√≥n para instalaciones multi-usuario
- DISPLAY: Configuraci√≥n X11 para sistemas Linux remotos y contenedores
- TMPDIR: Directorio temporal para archivos de trabajo y cache de interfaces

Consideraciones de Seguridad:
- Ejecuci√≥n con privilegios m√≠nimos para operaci√≥n segura en entornos corporativos
- Validaci√≥n de entrada para prevenci√≥n de inyecci√≥n de comandos
- Encriptaci√≥n opcional de comunicaciones TCP para aplicaciones sensibles
- Logging de auditor√≠a para trazabilidad completa de operaciones
- Integraci√≥n con sistemas de autenticaci√≥n empresariales (LDAP, Active Directory)

Optimizaciones de Rendimiento:
- Threading as√≠ncrono para operaciones de red sin bloqueo de interfaz
- Cache de interfaces Qt para reducci√≥n de tiempo de carga
- Gesti√≥n eficiente de memoria con cleanup autom√°tico de recursos
- Optimizaci√≥n de redibujado de interfaz para responsividad m√°xima
- Compresi√≥n opcional de datos de red para minimizaci√≥n de ancho de banda

Integraci√≥n con Ecosistema Cient√≠fico:
- Exportaci√≥n compatible con MATLAB, LabVIEW y Python cient√≠fico
- APIs REST para integraci√≥n con sistemas LIMS y bases de datos cient√≠ficas
- Soporte para formatos est√°ndar de instrumentaci√≥n (HDF5, NetCDF)
- Integraci√≥n con Jupyter Notebooks para an√°lisis interactivo
- Conectores para plataformas de IoT industrial (ThingSpeak, AWS IoT, Azure IoT)

Monitoreo y Mantenimiento:
- M√©tricas de rendimiento integradas con exportaci√≥n a Prometheus/Grafana
- Health checks autom√°ticos para detecci√≥n proactiva de problemas
- Logs estructurados para an√°lisis automatizado de patrones de fallo
- Sistema de alertas para condiciones an√≥malas de operaci√≥n
- Herramientas de diagnostic integradas para soporte t√©cnico remoto
