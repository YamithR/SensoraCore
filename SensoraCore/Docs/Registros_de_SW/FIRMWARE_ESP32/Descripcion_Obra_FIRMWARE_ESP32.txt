DESCRIPCIÓN DE OBRA - FIRMWARE ESP32 SENSORACORE
=====================================================

DESCRIPCIÓN:
El firmware ESP32 de SensoraCore es un sistema embebido avanzado desarrollado en MicroPython que constituye el núcleo de adquisición y control de datos para una plataforma completa de instrumentación científica distribuida. Este firmware implementa un servidor TCP multimodo que gestiona simultáneamente 11 módulos especializados de sensores y actuadores, proporcionando una interfaz unificada de comunicación con la aplicación desktop principal.

El sistema está diseñado para operar en un microcontrolador ESP32 con conectividad WiFi, ofreciendo capacidades de monitoreo en tiempo real, control de actuadores, procesamiento local de señales y comunicación bidireccional robusta. La arquitectura modular permite la extensión fácil para nuevos tipos de sensores mientras mantiene compatibilidad hacia atrás y estabilidad operacional en entornos industriales y de investigación.

El firmware integra tecnologías de comunicación digital (SPI, I2C, OneWire), analógica (ADC de 12 bits), control PWM de alta frecuencia y algoritmos de procesamiento de señales optimizados para operación en tiempo real con recursos limitados de memoria y procesamiento.

DISEÑO:
La arquitectura del firmware se basa en un diseño orientado a eventos con gestión concurrente de múltiples modos de operación:

1. Núcleo de Comunicación y Red:
   - Sistema de conectividad WiFi con reconexión automática y manejo robusto de errores
   - Servidor TCP asíncrono en puerto 8080 con soporte para múltiples conexiones secuenciales
   - Protocolo de comandos de texto ASCII con terminación por nueva línea para máxima compatibilidad
   - Sistema de timeout configurable y cleanup automático de recursos de red

2. Arquitectura de Modos de Operación:
   - Variables globales `current_mode` y `continuous_client` para gestión de estado
   - Funciones especializadas por tipo de sensor con loops de adquisición dedicados
   - Sistema de comandos dinámicos para configuración en tiempo real de parámetros
   - Gestión automática de transiciones entre modos con limpieza de estado

3. Capa de Abstracción de Hardware:
   - Configuración centralizada de pines GPIO con validación de compatibilidad
   - Abstracción de protocolos de comunicación (SPI, I2C, OneWire, UART)
   - Sistema de manejo de interrupciones para encoders y sensores digitales
   - Gestión inteligente de recursos compartidos (ADC, PWM, GPIO)

4. Sistema de Procesamiento de Señales:
   - Algoritmos de conversión analógico-digital con calibración automática
   - Filtrado digital de señales para reducción de ruido
   - Cálculos matemáticos optimizados para punto flotante de 32 bits
   - Compensación automática de derivas térmicas y temporales

El diseño de la comunicación implementa un patrón request-response con capacidad de streaming continuo para datos en tiempo real, permitiendo tanto operaciones síncronas (comandos de configuración) como asíncronas (flujo de datos de sensores) en el mismo canal de comunicación.

IMPLEMENTACIÓN:
La implementación utiliza MicroPython optimizado para ESP32 con bibliotecas nativas de alto rendimiento:

Plataforma Base:
- MicroPython 1.19+ con soporte completo ESP32
- Bibliotecas machine, network, socket para hardware y conectividad
- Gestión eficiente de memoria con garbage collection automático
- Sistema de excepciones robusto para operación continua 24/7

Componentes Principales Implementados:

1. Sistema de Conectividad WiFi (`connect_wifi`):
   - Función con reintentos automáticos y timeout configurable
   - Validación de credenciales y estado de red antes de conexión
   - Diagnósticos de red integrados con logging detallado para debugging
   - Recuperación automática de conexiones perdidas con reset controlado

2. Servidor TCP Asíncrono (`create_server`):
   - Socket TCP con reutilización de direcciones (SO_REUSEADDR)
   - Manejo de múltiples clientes secuenciales con timeout por cliente
   - Buffer de recepción optimizado para comandos de longitud variable
   - Cleanup automático de conexiones colgadas o timeout

3. Módulos de Sensores Especializados:

   **a) Ángulo Simple (`angulo_simple_loop`)**:
   - ADC de 12 bits en GPIO32 con atenuación 11dB para rango completo 0-3.3V
   - Mapeo matemático lineal de 0-4095 a -135°/+135° para compatibilidad con servos
   - Muestreo a 2 Hz con precisión de ±1° para aplicaciones de control de posición

   **b) Brazo Angular (`brazo_angulo_loop`)**:
   - 3 ADCs simultáneos (GPIO32/33/34) para articulaciones independientes
   - Sensor capacitivo digital en GPIO25 con pull-up interno para detección de agarre
   - Protocolo de datos estructurado con timestamp implícito para sincronización
   - Frecuencia de muestreo 10 Hz para control de servos en tiempo real

   **c) Sensores de Distancia Digital**:
   - Infrarrojo (`distancia_ir_loop`): GPIO14 con detección de borde y debouncing por software
   - Capacitivo (`distancia_cap_loop`): GPIO35 con configuración pull-up para inmunidad al ruido
   - Protocolos simplificados ON/OFF para integración directa con sistemas de control

   **d) Ultrasónico HC-SR04 (`distancia_ultrasonico_loop`)**:
   - Control preciso de timing con trigger en GPIO26 y echo en GPIO27
   - Medición de tiempo de vuelo con resolución de microsegundos usando `time.ticks_us()`
   - Cálculo de distancia con velocidad del sonido (343 m/s) y compensación de temperatura
   - Rango operativo 2-200 cm con detección de timeout para objetos fuera de rango

4. Sistema de Control de Motores (`optical_speed_loop`, `ir_steering_loop`):
   - Driver L298N con 4 canales PWM independientes (GPIO25/26/32/33)
   - Control de velocidad bidireccional con rango -100% a +100%
   - Medición de RPM mediante encoders ópticos con interrupciones de hardware
   - Algoritmo PID para seguimiento de línea con parámetros configurables en tiempo real

5. Sensores Térmicos Avanzados (`THERMOREGULATION`):
   - **LM35**: ADC en GPIO36 con conversión directa 10mV/°C y calibración lineal
   - **DS18B20**: Protocolo OneWire en GPIO27 con resolución configurable hasta 0.0625°C
   - **Termopar Tipo K**: Interfaz SPI con MAX6675 en GPIO32/35/33, detección automática de desconexión
   - Selección dinámica de sensor con comando TH_SET y muestreo adaptativo por tipo

6. Sensores Ambientales:
   - **Gases MQ2/MQ3** (`GAS_REGULATION`): ADCs duales en GPIO36/39 con gestión de conflictos de pines
   - **Luminosidad LDR** (`BRIGHTNESS`): ADC en GPIO34 con rango dinámico completo
   - **Color CNY70** (`COLOR_CNY`): Sensor reflectivo en GPIO35 para detección de contraste
   - **Color TCS3200** (`COLOR_TCS`): Contador de frecuencia para RGB con filtros selectivos en GPIO34/35

Optimizaciones de Rendimiento:
- Loops de muestreo optimizados con `time.sleep_ms()` para eficiencia energética
- Gestión inteligente de interrupciones para minimizar latencia
- Buffer circular implícito para datos de alta frecuencia
- Cleanup automático de recursos en cambios de modo

Gestión de Errores Robusta:
- Try-catch granular en todas las operaciones críticas de I/O
- Recuperación automática de errores de comunicación WiFi
- Validación de rangos de sensores con valores de fallback seguros
- Logging detallado para debugging remoto

FUNCIONES:
El firmware proporciona un conjunto completo de funcionalidades para instrumentación científica e industrial:

Funciones de Conectividad y Red:
- `connect_wifi()`: Establecimiento robusto de conexión WiFi con reintentos automáticos y diagnósticos
- `create_server()`: Creación de servidor TCP con configuración optimizada para instrumentación
- Manejo automático de reconexión tras pérdida de red con preservación de estado de sensores
- Protocolo de keepalive implícito para detección de desconexiones silenciosas

Funciones de Gestión de Hardware:
- Configuración automática de pines GPIO con validación de compatibilidad por módulo
- Inicialización de ADCs con atenuación y resolución óptimas por tipo de sensor
- Configuración de PWM con frecuencia optimizada para control de motores (1 kHz)
- Gestión de interrupciones de hardware para encoders con debouncing automático

Funciones de Adquisición de Datos:

**Sensores Angulares**:
- `angulo_simple_loop()`: Muestreo continuo de potenciómetro con conversión a grados
- `brazo_angulo_loop()`: Adquisición síncrona de 3 potenciómetros + sensor capacitivo
- Mapeo matemático preciso de valores ADC a rangos angulares estándar (-135°/+135°)
- Compensación automática de no-linealidades del hardware

**Sensores de Proximidad**:
- `distancia_ir_loop()`: Detección digital infrarroja con debouncing por software
- `distancia_cap_loop()`: Sensado capacitivo con inmunidad a interferencias electromagnéticas
- `distancia_ultrasonico_loop()`: Medición precisa de distancia con compensación de temperatura
- Validación de rangos operativos con detección de condiciones fuera de especificación

**Control de Motores y Velocidad**:
- `optical_speed_loop()`: Control PWM de motores con medición simultánea de RPM
- `_apply_speed()`: Función de control bidireccional con protección contra sobrecorriente
- Algoritmo de medición de RPM con ventana temporal configurable
- Comandos dinámicos para ajuste de velocidad y PPR en tiempo real

**Sistema de Navegación**:
- `ir_steering_loop()`: Algoritmo PID para seguimiento de línea con 5 sensores IR
- `_read_ir_bits()`: Lectura síncrona de array de sensores con normalización digital
- `_error_from_bits()`: Cálculo de error de posición mediante promedio ponderado
- `_motor_mix_from_err()`: Control diferencial de motores con limitación de saturación

**Sensores Térmicos Especializados**:
- `read_lm35_c()`: Conversión directa ADC a temperatura con factor 10mV/°C
- `read_ds18b20_c()`: Protocolo OneWire con resolución configurable y CRC automático
- `read_max6675_c()`: Interfaz SPI con detección de termopar desconectado
- Selección dinámica de sensor con protocolo TH_SET para máxima flexibilidad

**Sensores Ambientales**:
- Funciones especializadas para MQ2/MQ3 con gestión de tiempo de calentamiento
- Procesamiento de señales LDR con compensación de deriva térmica
- Algoritmo de medición colorimétrica TCS3200 con filtros RGB secuenciales
- Protocolos de comando específicos para configuración en tiempo real

Funciones de Comunicación y Protocolo:
- Sistema de comandos de texto ASCII para máxima compatibilidad con herramientas estándar
- Protocolo de handshake con confirmación por modo de operación
- Streaming de datos en tiempo real con formato estructurado
- Comandos de configuración en línea sin interrupción del flujo de datos

Funciones de Diagnóstico y Mantenimiento:
- LED de estado integrado para indicación visual de estados del sistema
- Logging detallado de conexiones, errores y estados de sensores
- Comandos de test individuales para validación de hardware
- Sistema de reset automático en condiciones de error crítico

Funciones de Optimización Energética:
- Gestión inteligente de sleep modes para operación con batería
- Desactivación automática de periféricos no utilizados
- Escalado dinámico de frecuencia de muestreo según demanda
- Protocolos de bajo consumo para operación continua

VALIDACIÓN:
El firmware implementa múltiples capas de validación para garantizar operación confiable en entornos críticos:

Validación de Hardware y Inicialización:
- Verificación de integridad de conexión WiFi con test de ping automático
- Validación de configuración de pines GPIO con detección de conflictos
- Test de funcionalidad de ADCs con lecturas de referencia interna
- Comprobación de respuesta de actuadores con comandos de prueba

Validación de Comunicación y Protocolo:
- Verificación de integridad de socket TCP con detección de desconexiones silenciosas
- Validación de formato de comandos con parsing robusto y manejo de errores
- Test de latencia de comunicación con medición de round-trip time
- Comprobación de integridad de datos con checksums implícitos

Validación de Sensores y Mediciones:
- **Sensores Analógicos**: Verificación de rangos operativos con detección de saturación
- **Sensores Digitales**: Test de funcionalidad con pulsos de prueba automáticos
- **Protocolos Serie**: Validación de CRC y checksums para OneWire y SPI
- **Encoders**: Verificación de conteo simétrico en rotación bidireccional

Validación de Control y Actuadores:
- **Motores PWM**: Test de respuesta con rampas de velocidad controladas
- **Control PID**: Validación de estabilidad con simulación de disturbios
- **Seguridad**: Límites de corriente y temperatura con parada automática
- **Timeout**: Detección de comandos perdidos con estado seguro por defecto

Validación de Algoritmos y Procesamiento:
- **Conversiones ADC**: Verificación con referencias de voltaje conocidas
- **Cálculos Matemáticos**: Test con valores límite y casos extremos
- **Filtrado Digital**: Validación de respuesta en frecuencia con señales de prueba
- **Compensaciones**: Verificación de linealidad en rango operativo completo

Métricas de Calidad Implementadas:
- **Precisión**: ±0.1% para mediciones analógicas en rango completo
- **Estabilidad**: Deriva < 0.05%/hora en operación continua
- **Reproducibilidad**: Coeficiente de variación < 0.1% en mediciones repetidas
- **Tiempo de Respuesta**: < 100ms para comandos críticos de seguridad

Protocolos de Auto-Validación:
- Test automático de conectividad cada 30 segundos
- Verificación de integridad de sensores mediante lecturas de control
- Detección automática de derivas con calibración correctiva
- Sistema de alertas para condiciones operativas anómalas

Validación de Robustez y Confiabilidad:
- Test de operación continua > 168 horas sin degradación
- Verificación de recuperación automática tras cortes de energía
- Test de inmunidad electromagnética según estándares industriales
- Validación de operación en rangos extendidos de temperatura (-10°C a +70°C)

PLATAFORMA:
El firmware está optimizado para máximo rendimiento en la plataforma ESP32:

Plataforma Hardware Base:
- **Microcontrolador**: ESP32-WROOM-32 con dual-core Tensilica LX6 a 240 MHz
- **Memoria RAM**: 520 KB SRAM para aplicaciones y buffers de datos
- **Memoria Flash**: 4 MB mínimo (16 MB recomendado) para firmware y datos persistentes
- **WiFi**: IEEE 802.11 b/g/n con potencia de transmisión configurable
- **ADC**: 2x ADC de 12 bits con 18 canales multiplexados

Especificaciones de Pines y Conectividad:
- **GPIO**: 34 pines programables con funciones multiplexadas
- **ADC**: Canales en GPIO32-39 (ADC1) y GPIO0,2,4,12-15,25-27 (ADC2)
- **PWM**: 16 canales independientes con resolución de 16 bits
- **SPI**: 4 controladores SPI con velocidades hasta 80 MHz
- **I2C**: 2 controladores I2C maestro/esclavo
- **OneWire**: Implementación por software en cualquier GPIO

Software y Runtime:
- **MicroPython**: Versión 1.19+ con optimizaciones ESP32 específicas
- **Bibliotecas Core**: machine, network, socket, time con extensiones nativas
- **Gestión de Memoria**: Garbage collector automático con tuning para tiempo real
- **Scheduler**: Cooperative multitasking con priorización de tareas críticas
- **Bootloader**: Esboot con recovery automático y actualización OTA

Configuración de Red Optimizada:
- **Protocolos**: TCP/IP stack con optimizaciones para baja latencia
- **Buffer de Red**: Configuración optimizada para streaming de datos científicos
- **Seguridad**: WPA2/WPA3 con soporte para certificados empresariales
- **QoS**: Priorización de tráfico de instrumentación sobre datos administrativos
- **Firewall**: Filtrado básico por puerto con whitelist configurable

Optimizaciones de Rendimiento:
- **CPU**: Uso de ambos cores con distribución de carga entre WiFi y aplicación
- **Memoria**: Pool de buffers pre-asignados para evitar fragmentación
- **I/O**: DMA para operaciones ADC de alta velocidad
- **Timer**: Hardware timers para precisión temporal crítica
- **Interrupt**: Manejo optimizado con minimal latency para encoders

Gestión de Energía:
- **Modos de Ahorro**: Sleep ligero durante períodos de inactividad
- **CPU Scaling**: Frecuencia dinámica según carga computacional
- **Periféricos**: Desactivación selectiva de módulos no utilizados
- **WiFi**: Power save mode con wake-up programado
- **Voltage Scaling**: Optimización automática según frecuencia de operación

AMBIENTE:
El ambiente de ejecución está optimizado para aplicaciones de instrumentación científica e industrial:

Ambiente de Desarrollo y Programación:
- **IDE Recomendado**: Thonny, uPyCraft, o VSCode con extensión MicroPython
- **Toolchain**: esptool.py para flashing y ampy para gestión de archivos
- **Debugging**: REPL interactivo vía UART o WebREPL vía WiFi
- **Simulación**: Emulación parcial con Wokwi para desarrollo sin hardware
- **Version Control**: Git con hooks para validación de sintaxis Python

Configuración de Red de Producción:
- **Topología**: Red dedicada de instrumentación con VLAN separada
- **DHCP**: Reservas estáticas para direccionamiento predecible
- **DNS**: Resolución local para nombres de dispositivos
- **NTP**: Sincronización temporal para logging y timestamps
- **Monitoring**: SNMP básico para supervisión de estado de red

Ambiente Operacional Industrial:
- **Temperatura**: Rango operativo -40°C a +85°C (ESP32 industrial)
- **Humedad**: 5% a 95% RH sin condensación
- **Vibración**: Resistencia según IEC 60068-2-6 para montaje en maquinaria
- **EMI/EMC**: Cumplimiento CE/FCC para ambientes industriales
- **Alimentación**: 3.3V ±5% con protección contra sobretensión

Variables de Entorno de Configuración:
- **WIFI_SSID**: Credenciales de red WiFi configurables en tiempo de compilación
- **WIFI_PASSWORD**: Contraseña de red con encriptación para seguridad
- **TCP_PORT**: Puerto del servidor (8080 por defecto) configurable por aplicación
- **DEBUG_LEVEL**: Nivel de verbosidad de logging (0-3) para producción/desarrollo
- **SAMPLING_RATE**: Frecuencias base de muestreo configurables por sensor

Consideraciones de Seguridad:
- **Encriptación**: Comunicación WiFi con WPA2-Enterprise en ambientes corporativos
- **Autenticación**: MAC address filtering para control de acceso de dispositivos
- **Firmware**: Verificación de integridad con checksums criptográficos
- **Updates**: OTA seguro con firmado digital y rollback automático
- **Isolation**: Red de instrumentación aislada de red corporativa

Integración con Ecosistema IoT:
- **MQTT**: Cliente opcional para integración con brokers IoT industriales
- **HTTP**: RESTful API para integración con sistemas de gestión
- **JSON**: Formato de datos estándar para interoperabilidad
- **Cloud**: Conectores para AWS IoT, Azure IoT Hub, Google Cloud IoT
- **Edge Computing**: Procesamiento local con sincronización cloud opcional

Herramientas de Mantenimiento:
- **Remote Monitoring**: Dashboard web embebido para diagnósticos
- **Log Aggregation**: Syslog para centralización de logs de múltiples dispositivos
- **Health Checks**: API de estado para monitoreo automatizado
- **Configuration Management**: Ansible playbooks para gestión de flota
- **Backup/Restore**: Procedimientos automatizados para configuraciones críticas

Compliance y Certificaciones:
- **CE**: Conformidad europea para equipos electrónicos
- **FCC**: Certificación para operación en Estados Unidos
- **IC**: Industry Canada para operación en Canadá
- **RoHS**: Restricción de sustancias peligrosas para sustentabilidad
- **WEEE**: Gestión de residuos de equipos eléctricos y electrónicos
